# Common
import numpy as np
import sys
from matplotlib import pyplot as plt
import scipy as sp

# Specialized

from colossus.lss import mass_function
from colossus.cosmology import cosmology

# Local
from ACTUtillity import *


def generate_semi_analytic_halo_catalogue(catalogue_volume,
                                          mass_params,
                                          z,
                                          h,
                                          visual_debugging=False,
                                          erase_debugging_folder=False,
                                          visual_debugging_path="./"):
    """ Function to generate the semi analytic halo catalogue (without coordinates) for galaxy testing

    :param catalogue_volume: float, cosmological volume within which to generate the catalog.
    :param mass_params: tuple, (mass low, mass high, spacing) in log10.
    :param z: float, redshift.
    :param h: float, reduced hubble constant.
    :param visual_debugging: bool, switch on visual debugging, which plots and outputs the black hole mass function.
    :param erase_debugging_folder: bool, if we should completely erase the contents of the folder we are writing plots
    to in advance of writing our own plots. Be exceptionally careful with this - it will list the files and ask for
    approval. If in doubt, leave False. We include this because old plots can lead to misinformation.
    :param visual_debugging_path: float, the path to which plots will be sent. Be careful where you point this if you
    set erase_debugging folder to True, as it will try and erase the contents.
    :return array, of halo masses (log10).
    """
    visual_debugging_housekeeping(visual_debugging=visual_debugging,
                                  function_name="generate_semi_analytic_halo_catalogue",
                                  erase_debugging_folder=erase_debugging_folder,
                                  visual_debugging_path=visual_debugging_path)

    bin_width = mass_params[2]
    mass_range = 10 ** np.arange(mass_params[0], mass_params[1], mass_params[2]) + np.log10(h)  # h^-1
    local_mass_function = mass_function.massFunction(mass_range, z, mdef='200m', model='tinker08', q_out='dndlnM') \
        * np.log(10) / h  # dn/dlog10M

    # Plot the halo mass function generated by colossus.
    if visual_debugging:
        fig = plt.figure()
        plt.xlabel('M200m')
        plt.ylabel('M')
        plt.title('Halo Mass function from Colossus')
        plt.loglog()
        plt.plot(mass_range, local_mass_function, '-', label='z = %.1f' % z)
        plt.legend()
        save_path = visual_debugging_path + 'Colossus_HMF.png'
        print("Writing file: {}".format(save_path))
        fig.savefig(save_path)
        plt.close()

    # We determine the Cumulative HMF starting from the high mass end, multiplied by the bin width.
    # This effectively gives the cumulative probability of a halo existing.
    cumulative_mass_function = np.flip(np.cumsum(np.flip(local_mass_function, 0)), 0) * bin_width

    ########################################################################
    # Interpolation Tests
    # Interpolator for the testing - we will update this with the volume in a second.
    # This is essentially for a volume of size unity.
    interpolator = sp.interpolate.interp1d(cumulative_mass_function, mass_range)

    sample_index = int(np.floor(len(cumulative_mass_function) / 2))  # index of the half way point
    num_test = cumulative_mass_function[sample_index]  # The value of the cum function at this index
    mass_test = interpolator(num_test)  # Interpolate to get the mass that this predicts
    # Check that these values are equivalent.
    assert mass_range[sample_index] == mass_test, \
        "Interpolation method incorrect: Back interpolation at midpoint failed"
    # Check first element is equivalent to the total to 10 SF accuracy
    assert np.round(cumulative_mass_function[0], 10) ==\
        np.round(np.sum(local_mass_function) * bin_width, 10), "Final cum sum element != total sum"
    ########################################################################

    # Multiply by volume
    cumulative_mass_function = cumulative_mass_function * catalogue_volume

    # Get the maximum cumulative number.
    max_number = np.floor(cumulative_mass_function[0])
    range_numbers = np.arange(max_number)

    # Update interpolator
    interpolator = sp.interpolate.interp1d(cumulative_mass_function, mass_range)
    mass_catalog = interpolator(range_numbers[range_numbers >= np.amin(cumulative_mass_function)])

    # Reconstruct HMF
    width = 0.1
    bins = np.arange(10, 16, width)
    hist = np.histogram(np.log10(mass_catalog), bins=bins)[0]
    hmf = (hist / catalogue_volume) / width

    # Plot both as a comparison
    if visual_debugging:
        # Plot both as a comparison
        plt.figure()
        plt.loglog()

        bins_power = 10 ** (bins[0:-1])

        plt.plot(bins_power[hmf != 0], hmf[hmf != 0], 'o', label='Reconstructed')
        plt.plot(mass_range, local_mass_function, label='Original')

        plt.legend()
        plt.xlabel("Halo Mass")
        plt.ylabel("Number Density")
        plt.title("Reconstructed HMF")

        save_path = visual_debugging_path + 'HMF_Validation.png'
        print("Writing file: {}".format(save_path))
        plt.savefig(save_path)
        plt.close()

    mass_catalog = np.log10(mass_catalog)
    return mass_catalog


def halo_mass_to_stellar_mass(halo_mass,
                              z,
                              formula="Grylls18",
                              scatter=0.001,
                              visual_debugging=False,
                              erase_debugging_folder=False,
                              debugging_volume=500 ** 3,
                              visual_debugging_path="./"):
    """Function to generate stellar masses from halo masses.

    This is based on Grylls 2018, but also has the option to use the
    parameters from Moster. This is a simplified version of Pip's
    DarkMatterToStellarMass() function.

    :param halo_mass: array, of halo masses (log10)
    :param z: float, the value of redshift
    :param formula: string, the method to use. Options currently include "Grylls18" and "Moster"
    :param scatter: bool, to scatter or not
    :param visual_debugging: bool, switch on visual debugging, which plots and outputs the stellar mass function.
    :param erase_debugging_folder: bool, if we should completely erase the contents of the folder we are writing plots
    to in advance of writing our own plots. Be exceptionally careful with this - it will list the files and ask for
    approval. If in doubt, leave False. We include this because old plots can lead to misinformation.
    :param debugging_volume: float, the cosmological volume, for the purposes of calculating the SMF for testing.
    :param visual_debugging_path: float, the path to which plots will be sent. Be careful where you point this if you
    set erase_debugging folder to True, as it will try and erase the contents.
    :return array, of stellar masses (log10).
    """
    visual_debugging_housekeeping(visual_debugging=visual_debugging,
                                  function_name="halo_mass_to_stellar_mass",
                                  erase_debugging_folder=erase_debugging_folder,
                                  visual_debugging_path=visual_debugging_path)

    # If conditions to set the correct parameters.
    if formula == "Grylls18":
        z_parameter = np.divide(z - 0.1, z + 1)
        m_10, shm_norm_10, beta10, gamma10, scatter = 11.95, 0.032, 1.61, 0.54, 0.11
        m_11, shm_norm_11, beta11, gamma11 = 0.4, -0.02, -0.6, -0.1
    elif formula == "Moster":
        z_parameter = np.divide(z, z + 1)
        m_10, shm_norm_10, beta10, gamma10 = 11.590, 0.0351, 1.376, 0.608
        m_11, shm_norm_11, beta11, gamma11 = 1.195, -0.0247, -0.826, 0.329
    else:
        assert False, "Unrecognised formula"

    # Create full parameters
    m = m_10 + m_11 * z_parameter
    n = shm_norm_10 + shm_norm_11 * z_parameter
    b = beta10 + beta11 * z_parameter
    g = gamma10 + gamma11 * z_parameter
    # Full formula
    # DM = self.effective_halo_mass
    internal_stellar_mass = np.log10(np.power(10, halo_mass) *
                                     (2 * n * np.power((np.power(np.power(10, halo_mass - m), -b)
                                                        + np.power(np.power(10, halo_mass - m), g)), -1)))
    # Add scatter, if requested.
    if not isinstance(type(scatter), type(True)):
        internal_stellar_mass += np.random.normal(scale=scatter, size=np.shape(internal_stellar_mass))

    # Generate the figures, if requested.
    if visual_debugging:
        width = 0.1
        bins = np.arange(9, 15, width)

        hist = np.histogram(internal_stellar_mass, bins=bins)[0]
        hmf = (hist / debugging_volume) / width
        log_smf = np.log10(hmf[hmf != 0])
        adj_bins = bins[0:-1][hmf != 0]

        plt.figure()
        plt.loglog()
        plt.plot(10 ** adj_bins, (10 ** log_smf), label="Grylls 2019")
        plt.xlabel("Stellar Mass")
        plt.ylabel("phi")
        plt.title("Stellar Mass Function, assigned from Pip's code")
        plt.legend()
        save_path = visual_debugging_path + 'SMF_Validation.png'
        print("Writing file: {}".format(save_path))
        plt.savefig(save_path)
        plt.close()

    return internal_stellar_mass


def stellar_mass_to_black_hole_mass(stellar_mass,
                                    method="Shankar16",
                                    scatter="Intrinsic",
                                    visual_debugging=False,
                                    erase_debugging_folder=False,
                                    debugging_volume=500 ** 3,
                                    visual_debugging_path="./figures/"):
    """ Function to assign black hole mass from the stellar mass.

    :param stellar_mass: array, of stellar masses in log10
    :param method: string, specifying the method to be used, current options are "Shankar16",  "KormondyHo" and "Eq4".
    :param scatter: string or float, string should be "Intrinsic", float value specifies the (fixed) scatter magnitude
    :param visual_debugging: bool, switch on visual debugging, which plots and outputs the black hole mass function.
    :param erase_debugging_folder: bool, if we should completely erase the contents of the folder we are writing plots
    to in advance of writing our own plots. Be exceptionally careful with this - it will list the files and ask for
    approval. If in doubt, leave False. We include this because old plots can lead to misinformation.
    :param debugging_volume: float, the cosmological volume, for the purposes of calculating the BHMF for testing.
    :param visual_debugging_path: float, the path to which plots will be sent. Be careful where you point this if you
    set erase_debugging folder to True, as it will try and erase the contents.
    :return: array, of the black hole masses (log10).
    """
    visual_debugging_housekeeping(visual_debugging=visual_debugging,
                                  function_name="stellar_mass_to_black_hole_mass",
                                  erase_debugging_folder=erase_debugging_folder,
                                  visual_debugging_path=visual_debugging_path)
    if method == "Shankar16":
        log_black_hole_mass = 7.574 + 1.946 * (stellar_mass - 11) \
                              - 0.306 * (stellar_mass - 11)**2. \
                              - 0.011 * (stellar_mass - 11)**3.
        if scatter == "Intrinsic" or scatter == "intrinsic":
            log_black_hole_mass += (0.32 - 0.1*(stellar_mass - 12.)) * np.random.normal(0., 1., len(stellar_mass))
        elif isinstance(type(scatter), float):
            log_black_hole_mass += np.random.normal(0., scatter, len(stellar_mass))
        else:
            assert False, "Unknown Scatter argument {}".format(scatter)

    elif method == "KormondyHo":
        log_black_hole_mass = 8.54 + 1.18 * (stellar_mass - 11)
        if scatter == "Intrinsic" or scatter == "intrinsic":
            print("Warning - Kormondy and Ho's intrinsic scatter is effectively fixed, with a scale of 0.5")
            scatter = np.random.normal(0, 0.5, len(stellar_mass))
            log_black_hole_mass += scatter
        elif isinstance(type(scatter), float):
            scatter = np.random.normal(0, scatter, len(stellar_mass))
            log_black_hole_mass += scatter
        else:
            assert False, "Unknown Scatter argument {}".format(scatter)

    elif method == 'Eq4':
        log_black_hole_mass = 8.35 + 1.31 * (stellar_mass - 11)
        if scatter == "Intrinsic" or scatter == "intrinsic":
            print("Warning - Eq4's intrinsic scatter is effectively fixed, with a scale of 0.5")
            scatter = np.random.normal(0, 0.5, len(stellar_mass))
            log_black_hole_mass += scatter
        elif scatter == "fixed":
            scatter = np.random.normal(0, scatter, len(stellar_mass))
            log_black_hole_mass += scatter
        else:
            assert False, "Unknown Scatter argument {}".format(scatter)
    else:
        assert False, "Unknown method when assigning black hole mass - {}".format(method)

    if visual_debugging:
        width = 0.1
        bins = np.arange(6, 10, width)

        hist = np.histogram(log_black_hole_mass, bins=bins)[0]
        black_hole_mf = (hist/debugging_volume)/width
        log_black_hole_mf = np.log10(black_hole_mf[black_hole_mf != 0])
        adj_bins = bins[0:-1][black_hole_mf != 0]

        plt.figure()
        plt.loglog()
        plt.plot(10**adj_bins, (10**log_black_hole_mf), label="{}".format(method))
        plt.xlabel("Black Hole Mass")
        plt.ylabel("phi")
        plt.title("Black Hole Mass Function")
        plt.legend()
        save_path = visual_debugging_path + "Black_Hole_Mass_Function.png"
        print("Writing file: {}".format(save_path))
        plt.savefig(save_path)
        plt.close()

    return log_black_hole_mass


def to_duty_cycle(method, stellar_mass, black_hole_mass, z=0, data_path="./Data/"):
    """ Function to assign duty cycle.

    :param method: string/float. If string, should be a method (currently "Mann" or "Schulze"), if float will be value.
    :param stellar_mass: array, the stellar masses in log10.
    :param black_hole_mass: array, the black hole masses in log10
    :param z: float, redshift
    :param data_path: string, path to the directory where the data is stored.
    :return: array, the duty cycle
    """

    method_type = type(method)
    if method_type is float or method_type is int:
        duty_cycle = np.ones_like(stellar_mass) * method
    elif isinstance(method, str):
        if method == "Mann":
            if z > 0.1:
                print("Warning - Mann's duty cycle is not set up for redshifts other than zero")
            mann_path = data_path + "Mann.csv"
            df = pd.read_csv(mann_path, header=None)
            mann_stellar_mass = df[0]
            mann_duty_cycle = df[1]
            get_u = sp.interpolate.interp1d(mann_stellar_mass, mann_duty_cycle)
            output = np.zeros_like(stellar_mass)
            output[stellar_mass < np.amin(mann_stellar_mass)] = np.amin(mann_duty_cycle)
            output[stellar_mass > np.amax(mann_stellar_mass)] = np.amax(mann_duty_cycle)
            cut = (stellar_mass < np.amax(mann_stellar_mass)) * (stellar_mass > np.amin(mann_stellar_mass))
            output[cut] = get_u(stellar_mass[cut])
            duty_cycle = 10 ** output

        elif method == "Schulze":
            # Find the nearest file to the redshift we want
            schulze_path = data_path + GetCorrectFile("Schulze", z, data_path)
            df = pd.read_csv(schulze_path, header=None)
            schulze_black_hole_mass = df[0]
            schulze_duty_cycle = df[1]
            duty_cycle = np.zeros_like(black_hole_mass)
            get_u = sp.interpolate.interp1d(schulze_black_hole_mass, schulze_duty_cycle)
            duty_cycle[black_hole_mass < np.amin(schulze_black_hole_mass)] = get_u(np.amin(schulze_black_hole_mass))
            duty_cycle[black_hole_mass > np.amax(schulze_black_hole_mass)] = get_u(np.amax(schulze_black_hole_mass))
            cut = (black_hole_mass > np.amin(schulze_black_hole_mass)) *\
                    (black_hole_mass < np.amax(schulze_black_hole_mass))
            duty_cycle[cut] = get_u(black_hole_mass[cut])
            duty_cycle = 10 ** duty_cycle
        else:
            assert False, "Unknown Duty Cycle Type {}".format(method)
    else:
        assert False, "No duty cycle type specified"

    assert duty_cycle.any() >= 0.0, "DutyCycle elements < 0 exist. This is a probabiliy, and should therefore not valid"
    assert duty_cycle.any() <= 1.0, "DutyCycle elements > 1 exist. This is a probabiliy, and should therefore not valid"
    return duty_cycle


def black_hole_mass_to_luminosity(black_hole_mass,
                                  duty_cycle,
                                  stellar_mass,
                                  z=0,
                                  method="Schechter",
                                  redshift_evolution=False,
                                  parameter1=-1,
                                  parameter2=-0.65,
                                  return_plotting_data=False,
                                  volume = 500**3):
    """ Function to assign the eddington ratios from black hole mass.

    :param black_hole_mass: array, the black hole mass (log10)
    :param duty_cycle: array, the duty cycle (only used for weightings in plotting data)
    :param stellar_mass: array, the stellar mass (log10)
    :param z: float, redshift
    :param method: string, the function to pull the Eddington Ratios from. Options are "Schechter", "PowerLaw" or
     "Gaussian".
    :param redshift_evolution: bool, if set to true will introduce a factor representing the z-evolution.
    :param parameter1: the first parameter for the method. For Schechter it is the knee, for PowerLaw it is not used,
    and for the Gaussian it is sigma.
    :param parameter2: the second parameter for the method. For Schechter it is alpha, for PowerLaw it is not used, for
    Gaussian it is b.
    :param return_plotting_data: bool, flag to return the plotting data for the eddington ratio distribution and the XLF
    :param volume: the cosmological volume, used for creating the plotting data.
    :return: luminosity (array), and if return_plotting_data is True, the XLF plotting data and eddington ratio
    distribution, both as PlottingData objects (see ACTUtillity).
    """

    def schechter_function(edd):
        gammaz = 3.47
        gammaE = parameter2
        z0 = 0.6
        A = 10. ** (-1.41)
        prob = ((edd / (10 ** parameter1)) ** gammaE)

        if redshift_evolution:
            prob *= ((1. + z) / (1. + z0)) ** gammaz

        if method == "Schechter":
            return prob * np.exp(-(edd / (10 ** parameter1)))
        elif method == "PowerLaw":
            return prob
        elif method == "Gaussian":
            return np.exp((edd-parameter2)**2/parameter1**2)
        else:
            assert False, "Type is unknown"

    l_edd = 38.1072 + black_hole_mass

    edd_bin = np.arange(-4, 1, 0.0001)
    prob_schechter_function = schechter_function(10 ** edd_bin)

    p = prob_schechter_function * (10**0.0001)
    r_prob = p[::-1]
    prob_cum = np.cumsum(r_prob)
    r_prob_cum = prob_cum[::-1]
    y = r_prob_cum / r_prob_cum[0]
    y = y[::-1]
    edd_bin = edd_bin[::-1]

    a = np.random.random(len(black_hole_mass))
    y2edd_bin = sp.interpolate.interp1d(y, edd_bin)
    lg_edd = y2edd_bin(a)  # lgedd = np.interp(a, y, edd_bin)  # , right=-99)
    l_bol = lg_edd + l_edd
    lg_l_bol = l_bol - 33.49
    lg_lum = lg_l_bol - 1.54 - (0.24 * (lg_l_bol - 12.)) - \
        (0.012 * ((lg_l_bol - 12.) ** 2.)) + (0.0015 * ((lg_l_bol - 12.) ** 3.))
    luminosity = lg_lum + 33.49

    if not return_plotting_data:
        return luminosity

    # Save Luminosity Function Data
    step = 0.1
    bins = np.arange(42, 46, step)
    lum_bins = sp.stats.binned_statistic(luminosity, duty_cycle, 'sum', bins=bins)[0]
    lum_func = (lum_bins/volume)/step
    xlf_plotting_data = PlottingData(bins[0:-1][lum_func > 0], np.log10(lum_func[lum_func > 0]))

    # Save Eddington Distribution Data
    step = 0.5
    lg_edd_derived = np.log10(25) + luminosity - (35.3802 + stellar_mass)  # log10(1.26e38 * 0.002) = 35.3802
    edd_bin = np.arange(-4, 1, step)
    prob_derived = stats.binned_statistic(lg_edd_derived, duty_cycle, 'sum', bins=edd_bin)[0] / (
                step * sum(duty_cycle))

    edd_bin = edd_bin[:-1]
    edd_bin = edd_bin[prob_derived > 0]
    prob_derived = prob_derived[prob_derived > 0]

    edd_plotting_data = (PlottingData(edd_bin, np.log10(prob_derived)))

    return luminosity, xlf_plotting_data, edd_plotting_data


if __name__ == "__main__":
    cosmo = 'planck18'
    cosmology = cosmology.setCosmology(cosmo)
    volume = 200**3

    halos = generate_semi_analytic_halo_catalogue(volume, (12, 16, 0.1), 0, 0.7,
                                                  visual_debugging=True,
                                                  erase_debugging_folder=True,
                                                  visual_debugging_path="./visualValidation/SemiAnalyticCatalog/")
    stellar_mass = halo_mass_to_stellar_mass(halos, 0,
                                             visual_debugging=True,
                                             erase_debugging_folder=True,
                                             debugging_volume=volume,
                                             visual_debugging_path="./visualValidation/StellarMass/")

    black_hole_mass = stellar_mass_to_black_hole_mass(stellar_mass,
                                                      method="Shankar16",
                                                      scatter="Intrinsic",
                                                      visual_debugging=True,
                                                      erase_debugging_folder=True,
                                                      debugging_volume=volume,
                                                      visual_debugging_path="./visualValidation/BlackHoleMass/")

    duty_cycle = to_duty_cycle(0.1, stellar_mass, black_hole_mass, 0)

    luminosity = black_hole_mass_to_luminosity(black_hole_mass, duty_cycle, stellar_mass, 0)

